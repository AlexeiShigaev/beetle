"""
Пойдем по столбцам, пока не встретим первую недоступную клетку.
Если исходить из обязательной смежности клеток для хода, без телепортаций, жуку доступна
только правая верхняя четверть - координаты, что X, что Y больше 1000;
поскольку уменьшение координат X или Y на 1 дают 999, а это уже больше 25.

Столбец с X координатой 1000 и Y от 1000 и выше по Y уже имеет к сумме по единице, т.е. 2
Нужна комбинация наименьших цифр, сумма которых будет до 24 (23 включительно)
Это 6+8+9. Другие не интересны - дают большие суммы.
Число 689 подойдет. После него 690, сумма уменьшилась, идем дальше, 698 дают 23, а уже 699 дают 24,
на эту клетку уже не шагнуть.

В столбце X=1000 максимальная клетка при движении строго вверх это 1698. Число клеток, соответственно, 699.
В столбце X=1001 максимальная клетка при движении строго вверх - 1598. Дает сумму 22. Число клеток 599.
В столбце X=1698 максимальная клетка при движении строго вверх - 1000. Дает сумму 0 (в том смысле,
что 23 уже в координате X). Число клеток 1.
и т.д.
Правда есть сомнения, что эту клетку нельзя обойти с соседней клетки...
"""
import time
from routins import sum_in_coordinates, sum_digits


def main():
    counter = 0  # подсчитываем клетки в переменную counter
    start_x = 0  # Подразумевается 1000, компенсируем в условии, не 25 а 23
    start_y = 0  # Подразумевается 1000, компенсируем в условии, не 25 а 23

    time_start = time.time()
    x = start_x
    while sum_digits(x) <= 23:
        column_counter = 0
        y = start_y
        summ = sum_in_coordinates(x, y)
        while summ <= 23:
            # print('\tклетка ({}, {}), sum={}'.format(x, y, summ))
            y += 1
            column_counter += 1
            summ = sum_in_coordinates(x, y)

        # print('столбец {}, column_counter={}'.format(x, column_counter))
        x += 1
        counter += column_counter

    time_end = time.time()
    print(f'Правый верхний квадрат содержит {counter} клеток удовлетворяющих нашему условию')
    print('Время выполнения:', time_end - time_start)


if __name__ == '__main__':
    main()
